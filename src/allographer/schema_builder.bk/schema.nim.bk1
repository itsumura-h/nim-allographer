import os, json, strutils, asyncdispatch, std/sha1, times, strformat
import ../base
import ../async/async_db
import ./table
import ./column
import ./migrates/migrate_interface
import ./migrates/sqlite_migrate
import ../query_builder
import ../utils


type MigrationTable = ref object
  name:string
  shouldRun:bool
  query:string
  txHash:string
  isCreateTable:bool

proc new(_:type MigrationTable,
  name:string,
  shouldRun:bool,
  query:string,
  txHash:string,
  isCreateTable:bool
):MigrationTable =
  return MigrationTable(
    name:name,
    shouldRun:shouldRun,
    query:query,
    txHash:txHash,
    isCreateTable:isCreateTable
  )


proc shouldRun(arr:seq[JsonNode], hash:string):bool =
  for row in arr:
    if row["tx_id"].getStr == hash and row["status"].getBool:
      return false
  return true

proc schema*(rdb:Rdb, tables:varargs[Table]) =
  let cmd = commandLineParams()
  let isReset = defined(reset) or cmd.contains("--reset")
  let migrateRepo =
    case rdb.conn.driver
    of SQLite3:
      SqliteMigrate.new(rdb).toInterface()
    else:
      SqliteMigrate.new(rdb).toInterface()

  # migration table definition
  let migrationTable = table(
    "allographer_migrations", [
      Column().uuid("tx_id"),
      Column().boolean("status"),
      Column().text("query"),
      Column().datetime("run_at")
    ]
  )
  block:
    let query = migrateRepo.migrateSql(migrationTable)
    try:
      rdb.conn.exec(query).waitFor
    except:
      rdb.log.logger(getCurrentExceptionMsg())


  # reset migration db
  if isReset:
    rdb.table("allographer_migrations").delete().waitFor


  # create table
  let migrationHistory = rdb.table("allographer_migrations").get().waitFor
  var migrationTables = newSeq[MigrationTable]()
  for table in tables:
    let query = migrateRepo.migrateSql(table)
    echo query
    let txHash = $query.secureHash()
    let shouldRun =
      if isReset:
        true
      else:
        migrationHistory.shouldRun(txHash)
    let migrationTable = MigrationTable.new(table.name, shouldRun, query, txHash, true)
    migrationTables.add(migrationTable)
    # index
    for column in table.columns:
      if column.isIndex:
        let (indexQuery,indexName) = migrateRepo.createIndex(table.name, column.name)
        # let indexQuery = migrateRepo.createIndex(table.name, column.name)
        let txHash = $indexQuery.secureHash()
        let shouldRun =
          if isReset:
            true
          else:
            migrationHistory.shouldRun(txHash)
        let migrationTable = MigrationTable.new(indexName, shouldRun, indexQuery, txHash, false)
        migrationTables.add(migrationTable)


  # drop table
  echo "===== drop table"
  for i in countdown(migrationTables.len-1, 0): # reverse loop
    let table = migrationTables[i]
    if table.shouldRun and table.isCreateTable:
      var tableName = table.name
      wrapUpper(table.name, rdb.conn.driver)
      let query = migrateRepo.dropTableQuery(tableName)
      try:
        rdb.log.logger(query)
        rdb.conn.exec(query).waitFor
      except:
        rdb.log.logger(getCurrentExceptionMsg())

  # drop index
  echo "===== drop index"
  for i in countdown(migrationTables.len-1, 0): # reverse loop
    let table = migrationTables[i]
    if table.shouldRun and not table.isCreateTable:
      let query = migrateRepo.dropIndexQuery(table.name)
      try:
        rdb.log.logger(query)
        rdb.conn.exec(query).waitFor
      except:
        rdb.log.logger(getCurrentExceptionMsg())


  # create table
  echo "===== create table"
  for table in migrationTables:
    if table.shouldRun and table.isCreateTable:
      var status = false
      # create table
      try:
        rdb.log.logger(table.query)
        rdb.conn.exec(table.query).waitFor
        status = true
      except:
        rdb.log.logger(getCurrentExceptionMsg())

      let runAt = $now().utc
      let query = migrateRepo.saveHistoryQuery(table.query, table.txHash, status, runAt)
      # save history to allographer_migrations
      try:
        rdb.log.logger(query, @[table.query, table.txHash, $status, runAt])
        rdb.conn.exec(query, @[table.query, table.txHash, $status, runAt]).waitFor
      except:
        rdb.log.logger(getCurrentExceptionMsg())


  # create index
  echo "===== create index"
  for table in migrationTables:
    if table.shouldRun and not table.isCreateTable:
      var status = false
      var didRun = false
      # create table
      try:
        rdb.log.logger(table.query)
        rdb.conn.exec(table.query).waitFor
        status = true
        didRun = true
      except:
        let err = getCurrentExceptionMsg()
        if err.contains("already exists"):
          rdb.log.echoErrorMsg(err)
          rdb.log.echoWarningMsg(&"Safety skip create table '{table.name}'")
        else:
          rdb.log.echoErrorMsg(err)

      if didRun:
        let runAt = $now().utc
        let query = migrateRepo.saveHistoryQuery(table.query, table.txHash, status, runAt)
        # save history to allographer_migrations
        try:
          rdb.log.logger(query, @[table.query, table.txHash, $status, runAt])
          rdb.conn.exec(query, @[table.query, table.txHash, $status, runAt]).waitFor
        except:
          rdb.log.logger(getCurrentExceptionMsg())


#[

マイグレーションテーブル作る

マイグレーションテーブルからデータ抜き出し

create table


]#